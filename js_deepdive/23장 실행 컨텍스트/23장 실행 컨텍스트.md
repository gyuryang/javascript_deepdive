# 23장 실행 컨텍스트

스터디 날짜: 2022년 10월 6일
완료 여부 : Done
작성자: 익명

## 23.1 소스코드의 타입

- **전역 코드**
    - 전역에 존재하는 소스코드
    - 전역에 정의된 함수, 클래스 등의 내부 코드는 포함 x
    - 전역 코드는 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 함
    - 전역 코드가 평가되면 전역 실행 컨텍스트 생성됨
- **함수 코드**
    - 함수 내부에 존재하는 소스코드
    - 함수 내부에 중첩된 함수, 클래스 등의 내부 코드 포함 x
    - 함수 코드는 지역 스코프를 생성하고 지역변수, 매개변수, arguments 객체를 관리해야 함
    - 함수 코드가 평가되면 함수 실행 컨텍스트가 생성됨
- **eval 코드**
    - 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드
    - eval 코드는 strict mode에서 자신만의 독자적인 스코프 생성
    - eval 코드가 평가되면 eval 실행 컨텍스트 생성됨
- **모듈 코드**
    - 모듈 내부에 존재하는 소스코드
    - 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않음
    - 모듈 코드는 모듈별로 독립적인 모듈 스코프 생성
    - 모듈 코드가 평가되면 모듈 실행 컨텍스트 생성됨

- 소스코드 (실행 가능한 코드)를 4가지 타입으로 구분하는 이유 → 소스코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문

## 23.2 소스코드의 평가와 실행

- 자바스크립트 엔진은 소스코드를 **소스코드의 평가**와 **소스코드의 실행** 과정으로 나누어 처리함

- **소스코드 평가 과정**
    - 실행 컨텍스트 생성
    - **변수, 함수 등의 선언문만을 먼저 실행**하여 생성된 변수나 함수 식별자를 키로, 실행 컨테스트가 관리하는 스코프에 등록
- **소스코드 평가 과정 이후**
    - **선언문을 제외한 소스코드가 순차적으로 실행됨** (런타임 시작)
    - 이 때 소스코드 실행에 필요한 정보, 즉 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득
    - 변수 값의 변경과 같은 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록됨
    
    ![Untitled](23%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%8F%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20747a11c4c63c40089fade907215b5c90/Untitled.png)
    
- 아래의 소스코드가 실행된다면,
    
    ```jsx
    var x;
    x = 1;
    ```
    
    1. 소스코드 평가 과정에서 변수 선언문 `var x;` 먼저 실행
    이 때 생성된 변수 식별자 x는 실행 컨텍스트가 관리하는 스코프에 등록되고 undefined로 초기화
    2. 소스코드 실행 과정에서는 변수 할당문 `x = 1;`만 실행됨
    3. 실행 컨텍스트가 관리하는 스코프에 x 변수가 등록되어 있는지 확인함 (x 변수가 선언된 변수인지 확인)
    4. x가 선언된 변수라면 값을 할당하고, 할당 결과를 실행 컨텍스트에 등록하여 관리
    

![소스코드의 평가](23%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%8F%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20747a11c4c63c40089fade907215b5c90/Untitled%201.png)

소스코드의 평가

![소스코드의 실행 ](23%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%8F%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20747a11c4c63c40089fade907215b5c90/Untitled%202.png)

소스코드의 실행 

## 23.3 실행 컨텍스트의 역할

- 자바스크립트 엔진이 평가하고 실행하는 순서
    1. 전역 코드 평가
    2. 전역 코드 실행
    3. 함수 코드 평가
    4. 함수 코드 실행
    
     + 예제를 통한 자세한 설명은 책 참고
    
- 코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요함 → 이 모든 것을 관리하는 것이 실행 컨텍스트
- **실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역**
- **실행 컨텍스트는 식별자 (변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘**
- **모든 코드는 실행 컨텍스트를 통해 실행되고 관리됨**

- 식별자와 스코프 → 실행 컨텍스트의 **렉시컬 환경**으로 관리
- 코드 실행 순서 → **실행 컨텍스트 스택**으로 관리

## 23.4 실행 컨텍스트 스택

- **실행 컨텍스트 스택** → **코드의 실행 순서 관리**. 생성된 실행 컨텍스트는 스택 자료구조로 관리됨.
- 콜 스택이라고 부르기도 함
- **실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행 중인 코드의 실행 컨텍스트 →** 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트를 **실행 중인 컨텍스트**라 부름

- 코드의 실행하는 시간의 흐름에 따라 실행 컨텍스트 스택에 실행 컨텍스트가 추가 (push)되고 제거 (pop)됨
    
    ```jsx
    const x = 1;
    
    function foo() {
      const y = 2;
    
      function bar() {
        const z = 3;
        console.log(x + y + z);
      }
      bar();
    }
    
    foo(); 
    ```
    
    ![Untitled](23%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%8F%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20747a11c4c63c40089fade907215b5c90/Untitled%203.png)
    
     + 예제에 관한 자세한 설명은 책 참고
    

## 23.5 렉시컬 환경

- **렉시컬 환경** → 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조. 실행 컨텍스트를 구성하는 컴포넌트.
- 키와 값을 갖는 객체 형태의 **스코프를 생성**하여 **식별자를 키로 등록**하고 **식별자에 바인딩된 값 관리** (저장소 역할)

- 렉시컬 환경은 두 개의 컴포넌트로 구성됨
    - **환경 레코드** → 스코프에 포함된 식별자를 등록하고, 등록된 식별자에 바인딩된 값을 관리하는 저장소
    - **외부 렉시컬 환경에 대한 참조 →** 상위 스코프를 가리킴. 상위 스코프는 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경.
    

## 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

```jsx
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}

foo(20); 
```

+ 각각 단계에 관한 자세한 설명은 책 참고

### 23.6.1 전역 객체 생성

- 전역 객체는 전역 코드가 평가되기 이전에 생성됨

### 23.6.2 전역 코드 평가

- 1. 전역 실행 컨텍스트 생성
- 2. 전역 렉시컬 환경 생성
    - 2.1. 전역 환경 레코드 생성
        - 2.1.1. 객체 환경 레코드 생성
        - 2.1.2. 선언적 환경 레코드 생성
    - 2.2. this 바인딩
    - 2.3. 외부 렉시컬 환경에 대한 참조 결정
    

### 23.6.3 전역 코드 실행

- 변수 할당문 또는 함수 호출문을 실행하려면 변수 또는 함수 이름이 선언된 식별자인지 확인해야 함
- 동일한 이름의 식별자가 다른 스코프에 여러 개 존재할 수 있음
- **식별자 결정** → 어느 스코프의 식별자를 참조하면 되는지 결정
- **식별자 결정을 위해, 식별자를 검색할 때는 실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작**

### 23.6.4 foo 함수 코드 평가

- 1. 함수 실행 컨텍스트 생성
- 2. 함수 렉시컬 환경 생성
    - 2.1. 함수 환경 레코드 생성
    - 2.2. this 바인딩
    - 2.3. 외부 렉시컬 환경에 대한 참조 결정
    

### 23.6.5 foo 함수 코드 실행

- **식별자 결정을 위해 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자 검색**
- 검색된 식별자에 값 바인딩

### 23.6.6 bar 함수 코드 평가

- foo 함수 코드 평가와 동일

### 23.6.7 bar 함수 코드 실행

1. console 식별자 검색
2. log 메서드 검색
3. 표현식 a + b + x + y + z의 평가 
4. console.log 메서드 호출

### 23.6.8 bar 함수 코드 실행 종료

- 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 pop되어 제거됨
- bar 함수 실행 컨텍스트가 소멸되었다 하더라도 만약 bar 함수 렉시컬 환경을 누군가 참조하고 있다면 bar 함수 렉시컬 환경은 소멸하지 않음

### 23.6.9. foo 함수 코드 실행 종료

- 실행 컨텍스트 스택에서 foo 함수 실행 컨텍스트가 pop 되어 제거됨

### 23.6.10 전역 코드 실행 종료

- 전역 실행 컨텍스트도 실행 컨텍스트 스택에서 pop되어, 실행 컨텍스트 스택에는 아무것도 남아있지 않음

## 23.7 실행 컨텍스트와 블록 레벨 스코프

- var 키워드로 선언한 변수 → 함수의 코드블록만을 지역 스코프로 인정
- let, const 키워드로 선언한 변수 → 모든 코드 블록을 지역 스코프로 인정

- 
    
    ```jsx
    let x = 1;
    
    if (true) {
      let x = 10;
      console.log(x); 
    }
    
    console.log(x); 
    ```
    
    - if문의 코드 블록 내에서 let 키워드로 변수 선언
    - if문의 코드 블록이 실행되면 if문의 코드블록을 위한 블록 레벨 스코프 생성
    - 이를 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체
    - if문 코드 블록의 실행이 종료되면 if문의 코드 블록이 실행되기 이전의 렉시컬 환경으로 되돌림