# 12장 함수

스터디 날짜: 2022년 9월 29일
완료 여부 : Done
작성자: 익명

## 12.1 함수란?

- 수학에서의 함수와 같이 입력을 받아 일련의 과정을 실행하고 결과값을 출력하는 일련의 과정
- 어떤 작업을 수행하기 위해 필요한 문(statement)들의 집합을 정의한 코드 블록
- 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 블록에 담긴 문들을 일괄적으로 실행할 수 있다.

![Untitled](12%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%206386248025404960aefbd42d580cf3ed/Untitled.png)

```tsx
// 함수의 정의(함수 선언문)
function square(number) {
  return number * number;
}

// 함수의 호출
square(2); // 4
```

## 12.2 함수를 사용하는 이유

- 함수는 필요할 때마다 여러번 호출할 수 있다.
- 함수는 실행 시점을 개발자가 정할 수 있다.
- 동일한 작업을 수행할 때 코드의 재사용이라는 측면에서 매우 유용하다.
- 유지보수의 편의성 향상, 코드의 신뢰성 향상
- 함수는 이름(식별자)를 붙일 수 있으므로, 코드를 다 읽지 않아도 함수의 역할을 예측할 수 있어 코드의 가독성을 높인다.

## 12.3 함수 리터럴

- 자바스크립트의 함수는 객체 타입의 값이다. 다른 프로그래밍 언어와 구별되는 자바스크립트의 중요한 특징.
- 따라서 객체 리터럴 표기법으로 객체를 만들수 있듯이( `var obj = { }` ), 함수도 함수 리터럴 표기법을 이용해 함수를 생성할 수 있다.
- 함수 리터럴은 `function 키워드`, `함수 이름`, `매개변수 목록, 함수 몸체`로 구성된다.
    
    ```tsx
    // 변수에 함수 리터럴을 할당
    var add = function add(x, y) {
      return x + y;
    };
    ```
    
- **함수 이름**
    - 함수 이름은 식별자이다. 따라서 식별자 네이밍 규칙을 준수해야 한다.
    - 함수 이름은 **함수 몸체 내에서만 참조할 수 있는 식별자**다.
    - **함수 이름은 생략할 수 있다.** 함수 이름이 있는 함수를 기명 함수(named function), 함수 이름이 없는 함수를 **익명 함수(anonymous function)**라 한다.
- **매개변수 목록**
    - 0개 이상의 매개변수를 괄호로 감싸고 쉼표로 구분한다.
    - 매개변수에는 인수가 할당된다.
    - 매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다.
- **함수 몸체**
    - 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.
    - 함수 몸체는 함수 호출에 의해 실행된다.

## 12.4 함수 정의

<aside>
❗ 다른 언어들과 다르게 자바스크립트는 정의와 선언의 구분이 모호하다. 예를들어 C에서는 실제로 메모리 주소를 할당하는가로 구별하는데, 자바스크립트의 경우 변수를 선언하면 암묵적으로 정의가 이루어지기 때문에 정의 구분이 모호하다. ECMAScript에서는 ‘변수를 선언한다.’ 고하고, ‘함수를 정의한다’고 한다고 말하고 있다.

</aside>

### 함수선언문

```jsx
function add(x,y) {
	return x + y;
}
```

- 함수선언문은 함수 리터럴과 형태가 동일하다.단, 함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다.
- 함수 선언문은 표현식이 아닌 문이다. 따라서 변수에 할당할 수 없다.
- 그러나 다음처럼 함수선언문이 변수에 할당된 것 처럼 보이는 경우가 있다.
    
    ```jsx
    var add = function add(x, y) {
      return x + y;
    };
    ```
    
    - 이는 자바스크립트 엔진이 문맥에따라 동일한 함수 리터럴을 표현식이아닌문인 함수선언식으로 해석하는 경우와 표현식인 함수 리터럴 표현식으로 해석하는 경우가 있기 때문이다.
    - 즉 기명함수 리터럴의 경우함수 선언문 또는 함수 리터럴 표현식으로 해석될 여지가 있다는 것이다.
    - 예를 들어 `{}` 는 블록문일 수도 있고, 객체 리터럴일 수도있는 중의적 표현이다. 문맥에따라 단독사용될 경우 블록문으로, 값으로 평가되어야할 경우 객체 리터럴로 해석한다.
    - 함수 리터럴을 피연산자가 아닌 단독으로 사용하면 함수선언문으로, 변수에 할당하거나 피연산자로 사용하면 함수 리터럴로 해석한다는 의미이기도하다.

```jsx
function add(x, y) {
  return x + y;
};

//add()로 호출가능

(function add(x, y) {
  return x + y;
};)

//호출불가함
```

- 위의 코드 첫번째 예제는 단독으로 사용된 함수 리터럴을 함수 선언문으로 해석하지만 아래는 그룹연산자를 사용하였으므로 함수 리터럴 표현식으로 해석된다.
- 함수 리터럴에서 함수이름은 함수 몸체 내에서만 참조할 수 있는 식별자라고 했다.  따라서 함수리터럴인 아래 예시는 `add()`를 호출할 수없다.
- 그럼 위는 왜 밖에서 호출이 가능한가? 자바스크립트가 암묵적으로 add라는 식별자를 생성했기 때문이다.
- 자바스크립트 엔진은 함수선언문을 해석해 함수객체를 생성한다. 이때 함수 식별자가 없으니, 생성된 함수를 호출할 수 있도록 함수이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수객체를 할당하는 것이다.
- 즉 함수는 함수이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.
- 결론적으로 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 생각할 수 있다.

### 함수 표현식

```jsx
var add = function(x,y) {
	return x + y;
}

//기명함수 표현식
var add = function foo(x,y) {
	return x + y;
}

foo() //error
add() //호출성공 
```

- 자바스크립트의 함수는 객체이므로 변수에 할당될 수도,프로퍼티의 값이될 수도, 배열의 요소가 될 수도 있다. 이처럼 값의 성질을 갖는 객체를 일급객체라고 한다.
- 따라서 함수리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식이라고 한다.
- 함수리터럴의 함수이름은 생략할 수 있고, 이를 익명함수라고 한다. 함수표현식의 함수리터럴은 이름을 생략하는 것이 일반적이다.
- 함수는 이름이아니라 식별자로 호출하므로, 위에서 아래 예시의 경우 add()로 호출하는것이 옳다.

### 함수선언문 VS 함수표현식

- 함수선언문과 함수표현식이 비슷하게 동작하는듯 보이지만, 함수선언문은 ‘표현식이 아닌문’ 함수표현식은’표현식인 문’임을 유념해라.
- 함수생성시점과 호이스팅에 유념해야한다.
    
    ```jsx
    //함수참조
    console.dir(add); //f add(x,y)
    console.dir(sub); //undefined
    
    //함수호출
    console.log(add(2,5)) //7
    console.log(sub(2,5)) //TypeError: sub is not a function
    
    //함수선언문
    function add(x,y) {
    	return x + y;
    }
    
    //함수표현식
    var sub = function(x,y) {
    	return x - y;
    }
    ```
    
    함수선언문으로 작성한 경우 함수 선언문 이전에 호출할 수 있고, 표현식 경우 불가능하다. 이는 함수선언문으로 정의한 함수와  함수표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.
    
    ---
    
    *함수선언문은…*
    
    - 모든 선언문이 그렇듯 함수선언문 역시 런타임 이전에 먼저 실행된다. 즉, 런타임 이전에 함수 객체가 먼저 생성된다. 그리고 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 함수 객체를 할당한다.
    - 즉, 런타임 이전에 이미 객체 생성, 식별자에 할당까지 완료된 상태이다. 따라서 함수 선언문 이전에 참조하고 호출할 수 있는 것이다. 이를 함수 호이스팅이라고 한다.
    
    ❗변수 호이스팅은 undefined로, 함수호이스팅은 함수 객체로 초기화된다. 따라서 이전에 참조할 경우 변수는 undefined가 나오지만, 함수는 호이스팅에 의해 함수 호출이 가능하다.
    
    ---
    
    *함수표현식은…*
    
    - 변수에 할당되는 값이 함수리터럴인 문이다. 따라서 변수 호이스팅에 의해 undefined로 초기화되고, 함수 리터럴은 런타임에 평가되어 함수 객체가 되는 것이다.
    - 다시말하자면, 함수표현식으로 함수를 정의하면 함수 호이스팅이아닌 변수호이스팅이 발생한다.
- 결론적으로, 함수호이스팅은 함수호출 이전에 함수가 선언되어야한다는 규칙을 무시해버린다. 때문에 함수선언문 대신 함수표현식을 사용할 것을 권장하기도 한다.

### Function 생성자함수

```jsx
var add = new Function('x','y', 'return x+y');
```

- Function 생성자 함수로 함수를 선언하는 것은 일반적이지않고, 권장되지도 않는다.
- 이렇게 생성된 함수는 클로저를 생성하지 않는 등 함수표현식, 함수선언식을 생성된 함수와 다르게 동작한다.

### 화살표 함수(es6)

```jsx
var add = (x,y) => x + y;
```

- 화살표함수는 함수를 더 간략하게 표현하고, 항상 익명으로 정의한다. (26절에서 다룰 예정)

## 12.5 함수 호출

- 함수는 함수를 가리키는 식별자와 한쌍의 소괄호인 함수 호출 연산자로 호출한다.
    
    ```tsx
    function add(x, y) {
    	return x+y;
    }
    
    var result = add(1,2)
    ```
    
    ### 매개변수
    
    - 매개변수는 함수를 정의할 때 선언하며, 함수 몸체 내부에서 변수와 동일하게 취급된다. 즉, 함수 호출 시 함수 몸체 내에서 암묵적으로 매개변수가 생성되고  일반 변수와 마찬가지로 undefined로 초기화된 후 인수가 순서대로 할당된다.
    - 매개변수는 함수 몸체 내에서만 유효하며, 외부에서 호출할 수 없다. (= 매개변수의 스코프는 함수 내부이다)
    - 함수는 매개변수와 인수의 개수가 같은지 체크하지않는다. 인수가 부족하여 할당되지 않은 변수는 undefined이고, 에러가 발생하지 않는다. 매개변수보다 인수가 많으면 초과 인수는 무시한다.
    - 또한 자바스크립트는 동적 타입 언어로서, 함수에 매개변수 타입을 사전에 지정할 수 없다. 함수 내부에 적절한 타입의 인수가 아니면 에러를 표시하도록 지정할 수 있으나, 사전에 방지하지 못하고 런타임에 발생하므로, 사전에 예방하기 위해 Typescript 등을 사용하는 것도 방법이다.
    - 매개변수의 최대갯수는 명시적으로 제한되고 있지않다. 이상적인 함수는 한가지 일만 해야하며 0개가 가장 바람직하고 가능한 한 적게 만들어야한다. 따라서 3개를 넘지 않을 것을 권장하며, 그 이상이 될 경우 객체형태를 인수로 전달하는 것이 좋겠다.
    - 매개변수로 객체를 사용할 경우, 키만 적확하다면 순서에 영향을 받지 않는다. 다만 객체는 함수내에서 변경하면 부수효과가 발생하니 유의하라.
    
    ### 반환문
    
    - 함수는 return 키워드와 표현식으로 이루어진 반환문을 사용해 실행결과를 함수 외부로 반환할 수 있다.
    - 반환문은 함수의 실행을 중단하고 함수를 빠져나가는 역할을 한다. 따라서 반환문 뒤에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.
    - 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환한다. 따라서 return 뒤에 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.
    - 반환문은 생략할 수 있으며, 암문적으로 undefined를 반환한다.
    
    - 반환문은 함수 내에서만 사용가능하고, 밖에서 사용할 경우 에러가 뜨지만 Node.js 환경에서는 모듈 시스템에 의해 파일별로 독립적인 스코프를 가지므로 파일 가장 바깥 영역에 반환문을 사용해도 에러가 발생하지 않는다.

## 12.6 참조에 의한 전달과 외부 상태의 변경

- 원시값은 값에 의한 전달(pass by value), 객체는 참조에 의한 전달(pass by reference)방식으로 동작한다.
- 매개변수 역시 함수 몸체 내부에서 변수와 동일하게 취급되므로, 타입에 따라 값에의한전달, 참조에의한전달을 그대로 따른다.
- 따라서 함수 내부 동작에따라 원시값은 값 자체가 복사되어 전달되고, 함수 밖의 값이 변하지 않지만, 객체타입은 참조값이 복사되어 전달되므로 원본이 훼손된다.
- 이처럼 함수가 외부상태를 변경하면 상태변화를 추적하기 어려워지고, 복잡성이 증가하며, 가독성을 해친다.
- 이를 막기위해 객체를 깊은복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다.
- 외부상태를 변경하지 않고 의존하지 않는 함수를 순수함수라고하고, 순수함수로 부수효과를 최대한 막아 프로그램의 안정성을 높이려는 패러다임을 함수형 프로그래밍이라고 한다.

## 12.7 다양한 함수의 형태

### 즉시 실행 함수

- 함수의 정의와 동시에 실행되는 함수를 즉시 실행 함수(IIFE, Immediately Invoke Function Expression)라고 한다. 최초 한번만 호출되며 다시 호출할 수는 없다. 이러한 특징을 이용하여 최초 한번만 실행이 필요한 초기화 처리등에 사용할 수 있다.
    
    ```jsx
    (function myFunction() {
      var a = 3;
      var b = 5;
      return a * b;
    }());
    
    // 익명 즉시 실행 함수(immediately-invoked function expression)
    (function (a,b) {
      return a * b;
    }(3,5));
    ```
    
- 즉시 실행 함수는 익명 함수를 사용하는 것이 일반적이다.
- 자바스크립트는 함수 코드블록을 닫는 중괄호 뒤에 `;`이 암묵적으로 추가되므로, 함수선언문 뒤의 `()`가 그룹연산자로 해석되고, 그룹연산자에 피연산자가 없으니 오류가 발생한다.
- 따라서 즉시 실행 함수는 반드시`()`에 넣어 사용한다.
- ()에 넣는 이유는 먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서다. 따라서 먼저 함수 리터럴을 평가해서 함수 객체를 생성할 수 있다면 이외에 다양한 방법들을 사용할 수 있다. (179p 예제 12-41)
- 즉시 실행함수 역시 값을 반환할 수 있고, 인수를 전달할 수도 있다.

### 재귀함수

- 재귀함수는 자기 자신을 호출하는 함수를 말한다.
- 재귀함수는 반복되는 처리를 위해 사용한다. 예시처럼 재귀함수를 활용하면 반복문없이 반복적처리를 구현할 수있다.

```jsx
// 팩토리얼
// n! = 1 * 2 * ... * (n-1) * n
function factorial(n) {
  if (n < 2) return 1;
  return factorial(n - 1) * n;
}

console.log(factorial(0)); // 1
console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120
console.log(factorial(6)); // 720
```

- 재귀함수 내부에서 호출된 식별자 factorial은 함수이름이다.
- 함수표현식으로 정의한 함수 내부에서는 함수이름은 물론 함수를 가르키는 함수 식별자로도 자기 자신을 재귀 호출할 수 있다.
- 재귀함수는 자신을 무한 재귀 호출 하므로, 재귀함수 내에는 반드시 재귀 호출을 멈출 수 있는 탈출조건을 만들어야한다.
- 탈출조건이 없으면 함수가 무한 호출되어 스택 오버 플로우 에러가 발생한다.
- 대부분의 재귀함수는 반복문으로 구현이 가능하므로, 재귀함수를 사용하는 것이 더 직관적일 때만 한정적으로 사용하는 것이 좋다.

### 중첩함수

- 함수 내부에 정의된 함수를 중첩함수(nested function) 혹은 내부함수(Inner function)라 한다. 중첩함수를 포함하고 있는 함수는 외부함수(outer function)이라고 한다.
- 아래 예제의 내부함수 child는 자신을 포함하고 있는 부모함수 parent의 변수에 접근할 수 있다. 하지만 부모함수는 자식함수(내부함수)의 변수에 접근할 수 없다.

```jsx
function parent(param) {
  var parentVar = param;
  function child() {
    var childVar = 'lee';
    console.log(parentVar + ' ' + childVar); // Hello lee
  }
  child();
  console.log(parentVar + ' ' + childVar);
  // Uncaught ReferenceError: childVar is not defined
}
parent('Hello');
```

- 일반적으로 중첩함수는 자신을 포함하는 아우터 함수를 돕는 헬퍼 함수 역할을 한다.
- es6부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능한데, 가령 if문 등의 내부에서도 정의가 가능하나, 호이스팅으로 인한 혼란이 발생할 수 있으므로 지양한다. 중첩함수는 스코프와 클로저에 깊은 관련이 있다.

### 콜백함수

- 콜백 함수(Callback function)는 함수를 명시적으로 호출하는 방식이 아니라 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수를 말한다.
- 콜백 함수가 자주 사용되는 대표적인 예는 이벤트 핸들러 처리이다.
    
    ```tsx
    <!DOCTYPE html>
    <html>
    <body>
      <button id="myButton">Click me</button>
      <script>
        var button = document.getElementById('myButton');
        button.addEventListener('click', function() {
          console.log('button clicked!');
        });
      </script>
    </body>
    </html>
    ```
    

- Javascript의 함수는 일급객체이다. 따라서 Javascript의 함수는 흡사 변수와 같이 사용될 수 있다.
- 콜백 함수는 매개변수를 통해 전달되고 전달받은 함수의 내부에서 **어느 특정시점**에 실행된다.
- 콜백 함수는 주로 비동기식 처리 모델(Asynchronous processing model)에 사용된다.
- 정리하자면, 매개변수를 통해 다른함수 내부로 전달되는 함수를 콜백함수라고 하고, 매개변수를 통해 함수의 외부에서 콜백함수를 전달받는 함수를 고차함수(Higher-Order Function, HOF)라고한다.
- 중첩함수가 외부함수를 돕는 헬퍼함수인 것처럼, 콜백함수는 고차함수를 돕는 헬퍼함수역할을한다. 다만 중첩함수와는 달리 외부에서 정의하고 매개변수로 전달하기 때문에, 교체가 용이하다. 즉, 고차함수는 콜백 함수를 자신의 일부분으로 합성한다.
- 고차함수가 콜백함수의 호출시점을 결정해서 호출하므로, 고차함수에 콜백함수를 전달할때는 함수를 호출하지않고 함수 자체를 전달해야함에 유의할 것.
- 고차함수 내부에서만 콜백함수를 사용할 경우 익명함수리터럴로 정의하며 곧바로 고차함수에전달하는것이 좋고, 다른곳에서도 사용한다면, 외부에서 정의하고 함수 참조를 고차함수에 전달하는 것이 효율적이다.

### 순수함수와 비순수함수

- 함수형 프로그래밍에서, 외부에 의존하지도 않고 변경하지도 않는, 즉 부수효과가 없는 함수를 순수함수라고하고, 부수효과가 있는 함수를 비순수함수라고 한다.
- 순수함수는 인수가 불변성이 있고 값을 변경 시키려면 변수에 할당에 변경해야한다.