# 27장 배열

스터디 날짜: 2022년 11월 3일
완료 여부 : Done
작성자: 익명

## 27.1 배열이란?

- **배열은  여러 개의 값을 순차적으로 나열한 자료구조다**.
    
    ```tsx
    const arr = ['바나나', 1, '딸기'];
    ```
    
- 배열이 가지고 있는 값을 `요소`라고한다. 자바스크립트의 모든 값은 요소가 될 수 있다. (원시값, 객체, 함수, 배열 등 포함)
- 배열의 요소는 배열에서 자신의 위치를 가리키는 0이상의 정수인 `인덱스`를 갖는다.
- 대부분의 프로그래밍 언어에서, 인덱스는 0부터 시작한다. 요소에 접근할 때는 대괄호 표기법과 인덱스를 이용한다.
- 또한 배열은 요소의 개수, 즉 배열의 길이를 나타내는 `length` 프로퍼티를 갖는다.
    
    ```tsx
    arr[1] ---> //'원숭이'
    arr.length ---> // 3
    ```
    

- 배열은 인덱스와 length를 갖고 있으므로, for문을 통해 각각의 요소에 순차적으로 접근할 수 있다.
    
    ```tsx
    for (let i = 0; i<arr.length; i++) {
    	console.log(arr[i]); // '바나나' '원숭이' '딸기'
    }
    ```
    

- 자바스크립트는 ‘배열’ 이라는 타입은 존재하지 않는다. 배열은 객체이다.
- 배열과 일반 객체를 구별하는 가장 큰 특징은 배열은 값의 순서와 length프로퍼티를 갖는다는 것이다.

## 27.2 자바스크립트 배열은 배열이 아니다.

- 자료구조에서 일반적으로 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 구조를 말한다.
    
    즉, 배열은 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 인접해있다. 이런 배열을 밀집배열(dense array)이라고 한다.
    
- 이러한 인반적인 배열은 인덱스를 통한 단 한번의 연산만으로 임의의 요소에 접근(임의접근, 시간복잡도 O(1))할 수 있으므로 매우 빠르고 효율적이다.
- 만약 정렬되지 않은 배열이라면, 특정 요소를 검색하는 경우 배열의 모든 요소를 처음부터 차례대로 순회하며 찾아야하므로, (선형검색, 시간복잡도 O(n)) 효율성이 현저히 떨어지게 된다.
- 일반적인 밀집 배열은 연속성을 유지하기 위해,  요소 삭제 및 삽입 시 다른 요소들을 이동시켜야한다는 단점이 있다.

- 자바스크립트의 배열은 일반적인 배열과 다르게 요소들이 각각 메모리공간이 같지 않아도되고, 연속적으로 이루어지지 않을 수도 있는 희소배열(sparse array)이다.
- 자바스크립트의 배열은 일반 배열을 흉내내는 특수한 객체이다.
- `Object.getOwnPropertyDescriptors()`를 이용해 배열의 내부를 살펴보면, js 배열은 인덱스를 나타내는 문자열을 프로퍼티로 가지고 있고, length프로퍼티르 갖는 특수한 객체이다. js의 모든 값은 객체의 프로퍼티 값이 될 수 있으므로, 배열 역시 js의 모든 타입을 요소로 가질 수 있는 것이다.

 

|  | 장점 | 단점 |
| --- | --- | --- |
| 일반배열 | - 인덱스 요소의 접근이 빠르다. | - 요소의 삽입, 삭제는 효율적이지 않다. |
| 자스의 배열 | - 해시테이블로 구현된 객체로, 요소 접근이 일반 배열보다 느리다. | - 요소의 삽입, 삭제가 일반 배열보다 빠르다. |

<aside>
❓ 해시테이블 :

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조이다. 각각의 Key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간복잡도로 데이터를 조회할 수 있다. 하지만 데이터의 충돌이 발생한 경우 Chaining에 연결된 리스트들까지 검색을 해야 하므로 O(N)까지 시간복잡도가 증가할 수 있다.

</aside>

- 모던자바스티입트 엔진은 배열을 일반 객체와 구별해 보다 배열처럼 작동하도록 최적화하여 구현했다. 따라서 자바스크립트의 배열은 객체보다는 2배정도 빠른 속도롤 보인다.

## 27.3 length프로퍼티와 희소배열

- length는 배열의 길이를 나타내므로, 0이상의 정수를 갖는다.
- 따라서 빈배열일 경우 0, 빈배열이 아닐 경우 가장 큰 인덱스에 1을 더한 값과 같다.
- length프로퍼티의 값은`0`과`2^23 - 1`(4,294,967,296 -1) 미만의 양의 정수이다. 즉 배열은 요소를 최대 `2^32 -1` 개 가질수 있고, 배열에서 사용할 수 있는 가장 큰 인덱스 값은 `2^23 -2` 이다.
- length의 값은 요소를 삭제하거나 추가하면 자동 갱신된다.
- 현재의 length보다 작은 숫자를 length에 할당하면, 배열의 길이가 줄어든다.
- 현재의 length보다 큰 숫자를 length에 할당하면, length프로퍼티의 값은 변하지만, 실제 배열의 길이가 늘어나지는 않는다.
    
    ```tsx
    const arr = [1];
    arr.length = 3;
    
    console.log(arr.length); //3
    console.log(arr); //[1, empty * 2]
    ```
    
    - empty *2 는 실제로 추가된 배열의 요소가 아니므로 arr[1], arr[2]에는 값이 존재하지 않는다.
    - 값이 비어져있는 요소를 위해 메모리를 확보하지않고, 그러면 빈요소를 생성하지도 않는다.
    - 이 경우 배열의 일부가 비어있으므로 희소배열이된다.

- 일반 배열은 배열의 요소 개수와 length가 항상 일치한다. 그러나 희소배열은 length와 배열의 개수가 일치하지 않는다. 희소 배열의  length는 실제 요소 갯수보다 언제나 크다.
- 희소배열은 자바스크립트 문법상 허용되지만, 성능면에서 매우 좋지 않으므로 사용을 지양한다. 배열을 만들때는 항상 같은 타입의 요소들을 연속적으로 배치해라.

## 27.4 배열생성

**1) 배열 리터럴**

- 요소를 쉼표로 구별하여 대괄호로 묶는다.
    
    ```tsx
    const arr = [1, 2, 3];
    const arr2 = [1, , 3];
    
    console.log(arr2[1]); // undefined;
    ```
    
- empty요소를 참조하면 undefined 반환 (arr2객체안에 프로퍼티키가 ‘1’인 프로퍼티가 존재하지 않기 때문)

**2) Array 생성자 함수**

- Array 생성자함수는 전달된 인수의 개수에 따라 다르게 작동하므로 주의해라.
    - 전달인수가 1개이고 숫자일경우:  희소배열 생성
        
        ```tsx
        const arr = new Array(10);
        console.log(arr, arr.length); // [empty*10], 10
        ```
        
    - 전달인수가 없으면 빈배열 생성 :  배열 리터럴 []과 동일하게 작동
        
        ```tsx
        new Array(); // []
        ```
        
    - 전달인수가 2개 이상이거나, 숫자가 아닌경우 : 인수를 요소로 갖는 배욜 생성
        
        ```tsx
        new Array(1, 2, 3); // [1,2,3]
        new Array({}); //[{}]
        ```
        

- Array 생성자 함수는 new없이 호출해도(일반함수로 호출해도) 생성자함수로 작동한다.

**3) Array.of**

- `Array.of()` 는 전달된 인수를 요소로 갖는 배열을 생성한다.

**4) Array.from**

- `Array.from()`은 유사배열객체, 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환한다.
    
    ```tsx
    Array.from({length:2, 0: 'a', 1: 'b'}); //['a', 'b']
    Array.from('Hello'); // ['H','e','l','l','o']
    ```
    
- `Array.from()` 의 두번째 인자에 콜백함수를 통해 요소를 채울 수도 있다.
    
    ```tsx
    Array.from({length : 3}); //[undefined, undefined, undefined]
    Array.from({length : 3}, (_,i)=>i); // [0,1,2]
    ```
    

## 27.5 배열 요소의 참조

- 배열의 요소를 직접 참조할 때는 대괄호[] 표기법을 사욜한다. 대괄호 안에는 인덱스가 온다.
- 배열의 인덱스는 객체의 프로퍼티 키와 같은 역할을 한다.
- 존재하지 않는 인덱스를 참조시 undefined를 반환한다.

## 27.6 배열 요소의 추가와 갱신

- 존재하지 않는 인덱스에 값을 할당하면 새로운 요소가 추가된다.
- 존재하는 인덱스에 값을 할당하면 요소값이 갱신된다.
- 정수이외의 값을 인덱스처럼 사용하면 요소가 생성되지않고 프로퍼티가 생성된다.
    
    ```tsx
    const arr=[];
    
    //요소추가
    arr[0] = 1;
    arr['1'] = 2;
    
    //프로퍼티추가
    arr['foo'] = 3;
    arr[1.1] = 4
    
    console.log(arr); // [1, 2, foo:3, '1.1':4]
    ```
    

## 27.7 배열 요소의 삭제

- 배열은 객체이므로, `delete`를 사용해 요소를 삭제할 수 있다.
    
    ```tsx
    const arr = [0,1,2];
    
    delete arr[1];
    console.log(arr); //[0, empty, 2]
    
    console.log(arr.length); // 3
    ```
    
    - delete는 객체의 프로퍼티를 삭제하므로, length에는 영향을 주지 않고 희소배열로 만들어버린다.
    - 따라서 사용을 지양한다

- `Array.prototype.splice(삭제를 시작할 인덱스, 삭제할 요소 수)`메서드를 사용한다.
    
    ```tsx
    const arr = [1, 2, 3];
    
    arr.splice(1, 1);
    console.log(arr); // [1,3]
    
    console.log(arr.length); // 2
    ```
    

## 27.8 배열 메서드

- 자바스크립트는 배열을 다룰 때 유용한 다양한 빌트인 메서드를 제공한다.
- 배열 메서드에는 원본배열을 직접변경하는 메서드와 직접 변경하지않고 새로운 배열을 생성하여 반환하는 메서드가 있다.
- es5 이후의 메서드들은 대체로  원본배열을 변경하지 않지만, 초창기 메서드들은 원본배열을 직접변경하는 경우가 많다. 원본배열을 직접 변경하는 것은 여러 부수효과들을 일으킬 수 있으므로  가급적 원본배열을 변경하지 않는 메서드를 이용하는 것이 좋다.

### 사용빈도가 높은 배열 메서드

`Array.isArray()`

- 전달된 인수가 배열인지 판별

`Array.prototype.indexOf(검색할 요소, 시작 인덱스)`

- 전달된 인수를 원본배열에서 검색하여 인덱스 반환
- 중복된 결과값이 있을 경우 첫번째로 검색된 인덱스만 반환
- 존재하지 않으면 -1 반환

`Array.prototype.includes()`

- 전달된 인수를 원본배열에서 검색하여 boolean반환

`Array.prototype.push()`

- 인수로 전달받은 모든 값을 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값 반환
- 성능면에서 좋지 않다. 만약 추가할 값이 한개라면 length프로퍼티를 이용하여 배열 마지막에 요소를 직접추가하는 것이 더 빠르다.
    
    ```tsx
    const arr = [1, 2];
    // arr.push(3)과 동일한 처리. push보다 빠름
    arr[arr.length] = 3;
    console.log(arr); // [1, 2, 3]
    ```
    
- push는 원본배열을 직접 변형한다. 스프레드 문법 사용 권장
    
    ```tsx
    const arr = [1, 2];
    
    const newArr = [...arr, 3];
    console.log(newArr); // [1, 2, 3]
    ```
    

`Array.prototype.pop()`

- 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환, 원본 배열이 빈배열이면 undefined반환
- pop은  원본배열을 직접 변형한다.
- pop과  push를 이용하면 스택(후입선출의 자료구조)을 쉽게 구현할 수 있다.

`Array.prototype.unshift()`

- 인수로 받은 모든 값을 원본 배열의 선두에 요소로 추가하고, 변경된 length 프로퍼티 값을 반환
- unshift는 원본배열을 직접 변형한다. 스프레드 문법 사용 권장

`Array.prototype.shift()`

- 원본배열에서 첫번째 요소를 제거하고, 제거한 요소를 반환, 원본 배열이 빈배열이면 undefined반환
- shift와  push를 이용하면 큐(선입선출의 자료구조)를 쉽게 구현할 수 있다.

`Array.prototype.concat()`

- 인수로 전달된 값들을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환
- 만약 전달한 값이 배열일 경우 배열을 해체하여 요소만 새로운 배열의 요소로 추가한다.
- concat은 원본배열을 변형하지않고 push와 unshift를 대체할 수 있다.

`Array.prototype.splice(시작,제거할 개수,제거한 위치에 삽입)`

- 원본 배열의 앞이나 뒤가 아닌 중간을 변형하고 싶다면 splice를 이용한다.
- 만약 시작인수가 -1이면 마지막 요소를 가리키고, -n 표현을 통해 뒤에서 n번째를 지정할 수 있다.
- splice는 원본배열을 변형한다.
- indexOf와 splice를 적절히 사용해 원하는 요소를 제거할 수도 있다.
- `filter()` 를 이용하면 중복된 특정 요소를 전부 제거한다.

`Array.prototype.slice(시작, 끝)`

- 인수로 전달된 범위의 요소들을 복사하여 배열로 반환 ( 시작부터 끝 이전 까지 반환)
- 원본배열을 변경하지 않는다.
- 끝 생략 시 시작부터 끝까지 복사하여 반환
- 모든 인수를 생략할시 원본배열 전체를 복사하여 반환하는데, 이는 얕은 복사이다.

❗️깊은 복사를 원하면  Lodash 라이브러리의  cloneDeep 메서드 추천

`Array.prototype.join(',')`

- 원본배열의 모든 요소를 문자열로 변환 후 인수로 전달받은 문자열(구분자)로 연결한 문자열 반환
- 생략할 경우 기본 구분자인 `,` 콤마로 연결하여 반환함

`Array.prototype.reverse()`

- 원본배열의 순서를 반대로 뒤집어서 반횐
- 원본배열을 변형함

`Array.prototype.fill(0, 시작, 끝)`

- 인수로전달받은 값으로 원본배열의 처음부터 끝까지 채워서 변경된 원본 배열 반환
- 시작과 끝을 지정하면 첫번쨰인수를 시작부터 끝 직전까지 채운다.
- 하나의 값으로만 채울 수 있다는 단점은 `Array.from()`으로 대체할 수 있다.

`Array.prototype.includes(검색대상, 시작인덱스)`

- 인수로 전달된 값이 원본배열에 있는지 없는지 판별해 boolean 반환
- `indexOf() !== -1` 를 이용해 동일한 효과를 낼 수 있지만, 반환값이 -1인지 판별해야하는 불편함이있고, NaN 이 포함되어있는지 알 수 없다는 한계가 있다.

`Array.prototype.flat(1)` [0,1,2 ,0,2]

- 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다.
- 생략하면 기본값은 1, Infinity를 전달할 경우 중첩배열을 모두 평탄화한다.

## 27.9 고차 배열 함수

- 고차함수는 함수를 인수로 전달받거나, 함수를 반환하는 함수를 말한다.

`Array.prototype.sort()`

- sort메서드는 배열의 요소를 정렬한다.
- 원본배열을 직접 변경하며, 변경된 배열을 반환한다.
- 기본적으로 오름차순으로 요소 정렬
- 내림차순을 사용하고 싶다면 sort() → reverse() 로 구현할 수 있다.

- 문자로 이루어진 배열을 정렬할 땐 위처럼해도 문제가 없지만, 숫자를 정렬할 땐 주의가 필요하다.
- sort는 기본적으로 유니코드포인트 순서를 따르는데, 이에따르면 의도한대로 정렬이 되지 않을 것이다.
- 따라서 숫자요소를 정렬할 때는 정렬 순서를 정의하는 비교함수를 인수로 전달해야한다.
- 비교함수에서 음수면 비교함수의 첫번째 인수를 먼저, 양수면 두번째 인수를 먼저, 0이면 정렬하지 않음
    
    ```tsx
    const points = [40, 100, 1, 5, 2, 25, 10];
    
    // 숫자 배열 오름차순 정렬
    // 비교 함수의 반환값이 0보다 작은 경우, a를 우선하여 정렬한다.
    points.sort(function (a, b) { return a - b; });
    // ES6 화살표 함수
    // points.sort((a, b) => a - b);
    console.log(points); // [ 1, 2, 5, 10, 25, 40, 100 ]
    
    // 숫자 배열에서 최소값 취득
    console.log(points[0]); // 1
    
    // 숫자 배열 내림차순 정렬
    // 비교 함수의 반환값이 0보다 큰 경우, b를 우선하여 정렬한다.
    points.sort(function (a, b) { return b - a; });
    // ES6 화살표 함수
    // points.sort((a, b) => b - a);
    console.log(points); // [ 100, 40, 25, 10, 5, 2, 1 ]
    
    // 숫자 배열에서 최대값 취득
    console.log(points[0]); // 100
    ```
    
    ```tsx
    const todos = [
      { id: 4, content: 'JavaScript' },
      { id: 1, content: 'HTML' },
      { id: 2, content: 'CSS' }
    ];
    
    // 비교 함수
    function compare(key) {
      return function (a, b) {
        // 프로퍼티 값이 문자열인 경우, - 산술 연산으로 비교하면 NaN이 나오므로 비교 연산을 사용한다.
        return a[key] > b[key] ? 1 : (a[key] < b[key] ? -1 : 0);
      };
    }
    
    // id를 기준으로 정렬
    todos.sort(compare('id'));
    console.log(todos);
    
    // content를 기준으로 정렬
    todos.sort(compare('content'));
    console.log(todos);
    ```
    

`Array.prototype.forEach((item, index, 원본배열)=>{})`

- forEach는 반복문을 추상화한 고차함수로서 내부에서 반복문을 통해 자신을 호출한 배열을 순회하면서 수행해야할 처리를 콜백함수로 전달받아 반복호출
    
    ```tsx
    const numbers = [1, 2, 3];
    let pows = [];
    
    // for 문으로 순회
    for (let i = 0; i < numbers.length; i++) {
      pows.push(numbers[i] ** 2);
    }
    
    console.log(pows); // [ 1, 4, 9 ]
    
    pows = [];
    
    // forEach 메소드로 순회
    numbers.forEach(function (item) {
      pows.push(item ** 2);
    });
    
    // ES6 화살표 함수
    // numbers.forEach(item => pows.push(item ** 2));
    
    console.log(pows); // [ 1, 4, 9 ]
    ```
    
- forEach는 원본배열을 변형시키지 않지만, 콜백함수의 3번째 인자를 이용해 원한다면 원본배열을 변형 시킬 수도 있다.
- forEach의 반환값은 언제나 undefined이다
- forEach는 for문과 달리  break, continue문을 사용할 수 없다. 따라서 모든 요소를 빠짐없이 순회해야하고, 희소배열의 경우 존재하지 않는 요소는 순회대상에서 제외된다. 이는 배열을 순회하는 `filter,` `map, reduce` 메서드에서도 마찬가지이다.

`Array.prototype.map((item, index, 원본배열)=>{})`

- 기본적으로 모든 인수를 순회하며 인수로 받은 콜백함수를 반복호출한다는 점이 forEach와 같지만, forEach가 항상 undefined를 반환하는 것과 달리 콜백함수의 반환값들로 이루어진 새로운 배열을 반환
- 원본배열을 변형하지 않는다.
- map이 반환한 배열은 원본배열의 length가 반드시 일치하고, 1:1 매핑한다.

`Array.prototype.filter((item, index, 원본배열)=>{})`

- 원본배열을 순회하면서 인수로 전달받은 콜백함수를 반복호출하며, 콜백함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환
- filter가 반환한 배열은 원본배열의 length보다 같거나 작다

`Array.prototype.reduce((accumulator, currentValue, index, 원본배열)=>{}, 초기값)`

- 원본배열을 순회하며 인수로 전달된 콜백함수를 호출하여 콜백함수의 반환값을 다음순회 시에 콜백함수의 첫번째 인수로 전달하면서 콜백함수를 재호출하여 하나의 결과값을 만들어 반환
    
    ```tsx
    const sum = [1, 2, 3, 4, 5].reduce(function (pre, cur) {
      return pre + cur;
    }, 5);
    
    console.log(sum); // 20
    // 5 + 1 => 6 + 2 => 8 + 3 => 11 + 4 => 15 + 5
    ```
    
- 항상 초기값을 생략하지말고 주는것이 안전하다.
- 추가 예시들을 보고 싶다면 책 p544~p547 참고

`Array.prototype.some((item, index, 원본배열)=>{})`

- 원본배열을 순회하며 인수로 전달된 콜백함수를 호출하여 단 한번이라도 참이면 true를, 모두 거짓이면 false 반환
- 조건에 맞는 요소가 한개라도 있는가?

`Array.prototype.every((item, index, 원본배열)=>{})`

- 원본배열을 순회하며 인수로 전달된 콜백함수를 호출하여 모든값이 참이면 true를, 아니면 false 반환
- 원본배열이 빈배열이면 언제나 true를 반환하므로 주의
- 모든 요소가 조건을 충족하는가?

`Array.prototype.find((item, index, 원본배열)=>{})`

- 원본배열을 순회하며 인수로 전달된 콜백함수를 호출하여 반환값이 true인 첫번쨰 요소를 반환
- filter와 유사하지만 filter는 항상 배열을 반환하고, find는 항상 해당 요소 하나를 반환한다.
- true가 없으면 undefined 반환

`Array.prototype.findIndex((item, index, 원본배열)=>{})`

- 원본배열을 순회하며 인수로 전달된 콜백함수를 호출하여 반환값이 true인 첫번쨰 요소의 index를 반환
- true 가 없으면 -1 반환

`Array.prototype.flatMap()`

- map을 통해 생성된  새로운 배열을 평탄화한다. 단, 깊이를 지정할 수없이 1단계만 평탄화함.