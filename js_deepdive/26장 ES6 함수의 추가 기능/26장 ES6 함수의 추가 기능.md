# 26장 ES6 함수의 추가 기능

스터디 날짜: 2022년 10월 13일
완료 여부 : Done
작성자: 익명

## 1 함수의 구분

- **ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로도 호출할 수 있음** 
→ **사용 목적에 따라 명확히 구분되지 않음**
- 이런 경우 명확한 구분이 없어서, 생성자 함수로 호출되지 않아도 프로토타입 객체를 생성함 → 성능 면에서 좋지 않음

- 이를 해결하기 위해 ES6에서는 **함수를 사용 목적에 따라 세 가지 종류로 구분**함
    
    ![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20ES6%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%2054310dd7fea0420996aeda6987efc7a5/Untitled.png)
    

## 2 메서드

- **ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미함**
- **ES6에서 정의한 메서드는 인스턴스를 생성할 수 없는 non-constructor** → 생성자 함수로서 호출할 수 없음
    
    ```jsx
    const obj = {
      x: 1,
      foo() { return this.x; }, // foo는 메서드 
      bar: function() { return this.x; } // bar에 바인딩된 함수는 일반 함수
    };
    ```
    

- **ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]]를 가짐 →** super 키워드를 사용할 수 있음
- 메서드를 정의할 때 프로퍼티 값으로 익명 함수 표현식을 할당하는 ES6 이전의 방식은 지양하는 것이 좋음

## 3 화살표 함수

### 3.1 화살표 함수 정의

- 함수 정의 → 함수 선언문으로 정의 x, **함수 표현식으로 정의**해야 함
    
    ```jsx
    const multiply = (x, y) => x * y;
    multiply(2, 3); 
    ```
    
- 매개변수 선언
    
    ```jsx
    // 매개변수가 여러 개인 경우 소괄호 안에 매개변수 선언 
    const arrow = (x, y) => { ... };
    
    // 매개변수가 한 개인 경우 소괄호 생략 가능 
    const arrow = x => { ... };
    
    // 매개변수가 없는 경우 소괄호 생략 불가능 
    const arrow = () => { ... };
    ```
    
- 함수 몸체 정의
    - 함수 몸체가 하나의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 생략 가능
        
        ```jsx
        // 둘은 동일한 표현 
        const power = x => x ** 2;
        const power = x => { return x ** 2; };
        ```
        
    - 객체 리터럴을 반환하는 경우 소괄호로 감싸 주어야 함
        
        ```jsx
        // 둘은 동일한 표현 
        const create = (id, content) => ({ id, content });
        const create = (id, content) => { return { id, content }; };
        ```
        
    - 화살표 함수도 즉시 실행 함수로 사용할 수 있음
        
        ```jsx
        const person = (name => ({
          sayHi() { return `Hi? My name is ${name}.`; }
        }))('Lee');
        ```
        
    - 화살표 함수도 고차 함수에 인수로 전달할 수 있음 → 이 경우 더 가독성이 좋음
        
        ```jsx
        // ES5
        [1, 2, 3].map(function (v) {
          return v * 2;
        });
        
        // ES6
        [1, 2, 3].map(v => v * 2); 
        ```
        

### 3.2 화살표 함수와 일반 함수의 차이

- **화살표 함수는 인스턴스를 생성할 수 없는 non-constructor** → 화살표 함수는 prototype 프로퍼티가 없고 프로토타입을 생성하지 x
- **화살표 함수는 중복된 매개변수 이름을 선언할 수 없음**
- **화살표 함수는 함수 자체의 this, arguments, super, [new.target](http://new.target) 바인딩을 갖지 않음** → 화살표 함수 내부에서 이것들을 참조하면 스코프 체인을 통해 상위 스코프의 것들을 참조함

### 3.3 this

- 화살표 함수의 this는 일반 함수의 this와 다르게 동작함
- ES6 이전에서는 **콜백 함수 내부의 this 문제**가 발생했음 → 콜백 함수의 this와 외부 함수의 this가 서로 다른 값을 가리키게 됨

- ES6에서는 화살표 함수를 사용하여 콜백 함수 내부의 this 문제 해결 가능
    - **화살표 함수는 함수 자체의 this 바인딩을 갖지 않음 → 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조함. 이를 lexical this라고 함**
    

### 3.4 super

- 화살표 함수는 함수 자체의 super 바인딩을 갖지 않음 → **화살표 함수 내부에서 super를 참조하면 상위 스코프의 super를 참조**

### 3.5 arguments

- 화살표 함수는 함수 자체의 arguments 바인딩을 갖지 않음 → **화살표 함수 내부에서 arguments를 참조하면 상위 스코프의 arguments를 참조**
- arguments 객체는 가변 인자 함수를 구현할 때 유용하지만, 화살표 함수에서는 사용할 수 없음
- 화살표 함수로 가변 인자 함수를 구현해야 할 때는 Rest 파라미터 사용

## 4 Rest 파라미터

### 4.1 기본 문법

- **Rest 파라미터** → 매개변수 이름 앞에 세개의 점을 붙여서 정의한 매개변수
- **함수에 전달된 인수들의 목록을 배열로 전달받음**
    
    ```jsx
    function foo(...rest) {
      console.log(rest); // [ 1, 2, 3, 4, 5 ]
    }
    
    foo(1, 2, 3, 4, 5);
    ```
    

- 일반 매개변수와 Rest 파라미터를 함께 사용할 수 있음
- 함수에 전달된 인수들은 매개변수와 Rest 파라미터에 **순차적으로** 할당됨
- Rest 파라미터에는 먼저 선언된 매개변수에 할당된 인수를 제외한 나머지 인수들로 구성된 배열이 할당됨 → **반드시 마지막 파라미터여야 함**
- Rest 파라미터는 하나만 선언할 수 있음
    
    ```jsx
    function bar(param1, param2, ...rest) {
      console.log(param1); // 1
      console.log(param2); // 2
      console.log(rest);   // [ 3, 4, 5 ]
    }
    
    bar(1, 2, 3, 4, 5);
    ```
    
    <aside>
    💡 **rest** 
    - 함수에 전달된 인수들의 목록을 배열로 전달받기 위해 매개변수 이름 앞에 …을 붙이는 것
    
    **spread**
     - 여러 개의 값이 하나로 뭉쳐 있는 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만드는 것
    
    </aside>
    

### 4.2 Rest 파라미터와 arguments 객체

- **arguments 객체는 유사 배열 객체**이므로, 배열 메서드를 사용하려면 arguments 객체를 배열로 변환해야 하는 번거로움이 있음
- ES6에서는 **rest 파라미터를 사용하여 가변 인자 함수의 인수 목록을 배열로 직접 전달받을 수 있음** → 위의 번거로움을 피할 수 있음
- 화살표 함수로 가변 인자 함수를 구현할 때는 항상 Rest 파라미터를 사용해야 함

## 5 매개변수 기본값

- 함수를 호출할 때 매개변수 개수만큼 인수를 전달하지 않아도 에러가 발생하지 않음
- 인수가 전달되지 않은 매개변수 값은 undefined → 의도치 않은 결과가 나올 수 있음

- **매개변수에 인수가 전달되었는지 확인하고, 인수가 전달되지 않은 경우 매개변수에 기본값을 할당할 필요가 있음** → 방어 코드
    
    ```jsx
    function sum(x, y) {
      x = x || 0;
      y = y || 0;
    
      return x + y;
    }
    
    console.log(sum(1, 2)); // 3
    console.log(sum(1));    // 1
    ```
    
- **ES6에서 도입된 매개변수 기본값** → 매개변수에 인수를 전달하지 않은 경우 or undefined를 전달한 경우만 유효
- Rest 파라미터에는 기본값 지정 불가능
    
    ```jsx
    function sum(x = 0, y = 0) {
      return x + y;
    }
    
    console.log(sum(1, 2)); // 3
    console.log(sum(1));    // 1
    ```